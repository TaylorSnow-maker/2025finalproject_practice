Nice — here’s a single-file (one `.html`) Snake game you can copy/paste and open in a browser. It includes keyboard (arrows + WASD), swipe (mobile), pause/restart, score + high score (localStorage), and smooth canvas rendering.

Paste the whole file into `snake.html` and open it.

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake — Single File</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#0f1724;
    --accent:#22c55e;
    --muted:#94a3b8;
    --danger:#ef4444;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#06101a);color:#e6eef8}
  .wrap{
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    gap:20px;
    padding:28px;
    box-sizing:border-box;
  }
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.03);
    padding:18px;
    border-radius:12px;
    box-shadow:0 6px 30px rgba(2,6,23,0.6);
    display:flex;
    gap:16px;
    align-items:center;
  }
  .left{
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:center;
  }
  canvas{
    background:linear-gradient(180deg,#07101a, #09202a);
    border-radius:8px;
    display:block;
    image-rendering:pixelated;
    touch-action:none;
  }
  .hud{
    display:flex;
    flex-direction:column;
    gap:8px;
    padding:6px 8px;
    min-width:220px;
  }
  h1{font-size:18px;margin:0 0 4px 0}
  .score{
    display:flex;justify-content:space-between;align-items:center;
    background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-weight:600
  }
  .muted{color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  button{
    background:transparent;border:1px solid rgba(255,255,255,0.06);
    color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer;
    font-weight:600;
  }
  button.primary{background:linear-gradient(90deg,#1f8a4b,#2cc76b);color:#04240b;border:0}
  .small{font-size:13px;padding:6px 8px}
  .footer{margin-top:10px;color:var(--muted);font-size:13px;text-align:center}
  @media (max-width:720px){
    .card{flex-direction:column}
    .hud{width:100%}
    canvas{width:320px;height:320px;max-width:92vw}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="application" aria-label="Snake Game">
    <div class="left">
      <canvas id="c" width="480" height="480"></canvas>
      <div class="muted small">Use arrows or WASD. Swipe on mobile. Press P to pause.</div>
    </div>

    <div class="hud" aria-hidden="false">
      <h1>Snake</h1>
      <div class="score">
        <div>Score</div>
        <div id="score">0</div>
      </div>
      <div class="score">
        <div>Best</div>
        <div id="best">0</div>
      </div>

      <div class="muted">Speed</div>
      <input id="speed" type="range" min="4" max="18" value="8" />

      <div class="controls">
        <button id="start" class="primary small">Start / Restart</button>
        <button id="pause" class="small">Pause</button>
        <button id="mute" class="small">Mute</button>
        <button id="easy" class="small">Easy</button>
        <button id="hard" class="small">Hard</button>
      </div>

      <div class="muted footer">Tiles: <span id="tiles">20</span> · Grid-based classic snake</div>
    </div>
  </div>
</div>

<script>
(() => {
  // --- Config ---
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const speedRange = document.getElementById('speed');
  const tilesDisplay = document.getElementById('tiles');
  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const muteBtn = document.getElementById('mute');
  const easyBtn = document.getElementById('easy');
  const hardBtn = document.getElementById('hard');

  // logical grid size (number of cells per side)
  let grid = 20;
  tilesDisplay.textContent = grid;

  // rendering size
  const size = canvas.width; // square canvas
  let cell = Math.floor(size / grid);

  // game state
  let snake, dir, nextDir, food, running, score, best, speed, tickTimer, paused=false;
  const LS_KEY = 'singlefile_snake_best_v1';

  // simple sounds (WebAudio)
  let audioCtx = null;
  let soundsOn = true;
  function playTone(freq, time=0.05) {
    if(!soundsOn) return;
    try {
      if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.08;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
      o.stop(audioCtx.currentTime + time + 0.02);
    } catch(e){ /* ignore audio errors */ }
  }

  function randCell() {
    return {
      x: Math.floor(Math.random()*grid),
      y: Math.floor(Math.random()*grid)
    };
  }

  function equal(a,b){ return a.x===b.x && a.y===b.y; }

  function placeFood() {
    let tries = 0;
    while(true){
      const p = randCell();
      if(!snake.some(s => equal(s,p))) {
        food = p;
        return;
      }
      if(++tries>500) { // fallback
        food = { x:0,y:0 }; return;
      }
    }
  }

  function reset() {
    cell = Math.floor(size / grid);
    snake = [
      {x:Math.floor(grid/2), y:Math.floor(grid/2)},
      {x:Math.floor(grid/2)-1, y:Math.floor(grid/2)},
      {x:Math.floor(grid/2)-2, y:Math.floor(grid/2)}
    ];
    dir = {x:1,y:0};
    nextDir = dir;
    placeFood();
    score = 0;
    running = true;
    paused = false;
    updateScoreUI();
  }

  function loadBest(){ best = Number(localStorage.getItem(LS_KEY) || 0); bestEl.textContent = best; }
  function saveBest(){ if(score>best){ best = score; localStorage.setItem(LS_KEY, best); bestEl.textContent = best; } }

  // Game step
  function step() {
    if(!running || paused) return;
    // change direction if valid (no 180)
    if((nextDir.x !== -dir.x || nextDir.y !== -dir.y) ) dir = nextDir;

    // new head
    const newHead = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // wrap-around OR collision? We'll wrap-around to make it friendly.
    newHead.x = (newHead.x + grid) % grid;
    newHead.y = (newHead.y + grid) % grid;

    // collision with self?
    if(snake.some(s => equal(s,newHead))) {
      // game over
      playTone(120,0.12);
      running = false;
      saveBest();
      flashGameOver();
      return;
    }

    snake.unshift(newHead);

    // food?
    if(equal(newHead, food)){
      score += 1;
      playTone(900 - Math.min(700, score*8), 0.06);
      placeFood();
    } else {
      snake.pop();
    }
    updateScoreUI();
  }

  function updateScoreUI(){
    scoreEl.textContent = score;
  }

  // Drawing
  function draw() {
    // clear
    ctx.clearRect(0,0,size,size);

    // background grid subtle
    ctx.fillStyle = "#071722";
    ctx.fillRect(0,0,size,size);

    // draw food
    const fx = food.x*cell, fy = food.y*cell;
    roundRect(ctx, fx+cell*0.12, fy+cell*0.12, cell*0.76, cell*0.76, 6);
    ctx.fillStyle = "#ff6347"; ctx.fill();

    // draw snake body
    for(let i=snake.length-1;i>=0;i--){
      const p = snake[i];
      const x = p.x*cell, y = p.y*cell;
      if(i===0){
        // head
        roundRect(ctx, x+1,y+1,cell-2,cell-2,6);
        ctx.fillStyle = "#22c55e";
        ctx.fill();
        // eye
        ctx.fillStyle = "#03220f";
        const ex = x + (dir.x>0 ? cell*0.64 : dir.x<0 ? cell*0.18 : cell*0.5);
        const ey = y + (dir.y>0 ? cell*0.64 : dir.y<0 ? cell*0.18 : cell*0.34);
        ctx.beginPath(); ctx.arc(ex, ey, Math.max(1,cell*0.06), 0, Math.PI*2); ctx.fill();
      } else {
        // gradientish body
        const t = i / Math.max(1, snake.length-1);
        ctx.fillStyle = `rgba(34,197,94,${0.55 + 0.35*(1-t)})`;
        roundRect(ctx, x+1,y+1,cell-2,cell-2,6);
        ctx.fill();
      }
    }

    // HUD overlay small grid lines (optional subtle)
    ctx.strokeStyle = "rgba(255,255,255,0.02)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let i=1;i<grid;i++){
      const px = i*cell + 0.5;
      ctx.moveTo(px,0); ctx.lineTo(px,size);
      const py = i*cell + 0.5;
      ctx.moveTo(0,py); ctx.lineTo(size,py);
    }
    ctx.stroke();
  }

  function roundRect(ctx, x, y, w, h, r){
    const min = Math.min(w,h)/2;
    if(r>min) r=min;
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Game loop timer
  function setSpeed(v){
    speed = Number(v); // steps per second
    if(tickTimer) clearInterval(tickTimer);
    tickTimer = setInterval(step, Math.round(1000/speed));
  }

  // flash game over
  let gameOverFlash = 0;
  function flashGameOver(){
    let flashes = 6;
    const i = setInterval(() => {
      gameOverFlash ^= 1;
      if(--flashes<=0){ clearInterval(i); gameOverFlash = 0; }
      canvas.style.filter = gameOverFlash ? "brightness(1.05) saturate(1.1)" : "";
    },100);
  }

  // Input
  window.addEventListener('keydown', (e) => {
    if(!running) {
      if(e.key === " "){ start(); e.preventDefault(); return; }
    }
    if(e.key === 'p' || e.key === 'P'){ paused = !paused; pauseBtn.textContent = paused ? "Resume" : "Pause"; return; }
    if(e.key === 'm' || e.key === 'M'){ toggleMute(); return; }
    const k = e.key;
    if(k === "ArrowUp" || k === "w" || k==="W") setNextDir(0,-1);
    if(k === "ArrowDown" || k === "s" || k==="S") setNextDir(0,1);
    if(k === "ArrowLeft" || k === "a" || k==="A") setNextDir(-1,0);
    if(k === "ArrowRight" || k === "d" || k==="D") setNextDir(1,0);
  });

  function setNextDir(x,y){ nextDir = {x,y}; }

  // Pointer / Swipe for mobile
  let touchStart = null;
  canvas.addEventListener('pointerdown', (e) => {
    touchStart = {x:e.clientX, y:e.clientY};
  });
  window.addEventListener('pointerup', (e) => {
    if(!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    const absx = Math.abs(dx), absy = Math.abs(dy);
    if(Math.max(absx,absy) > 20){
      if(absx > absy){
        setNextDir(dx>0?1:-1, 0);
      } else {
        setNextDir(0, dy>0?1:-1);
      }
    } else {
      // tap = pause/resume
      paused = !paused; pauseBtn.textContent = paused ? "Resume" : "Pause";
    }
    touchStart = null;
  });

  // UI buttons
  startBtn.addEventListener('click', start);
  pauseBtn.addEventListener('click', () => {
    paused = !paused; pauseBtn.textContent = paused ? "Resume" : "Pause";
  });
  muteBtn.addEventListener('click', toggleMute);

  easyBtn.addEventListener('click', () => {
    grid = 16; tilesDisplay.textContent = grid; reset(); setSpeed(speedRange.value);
  });
  hardBtn.addEventListener('click', () => {
    grid = 28; tilesDisplay.textContent = grid; reset(); setSpeed(speedRange.value);
  });

  speedRange.addEventListener('input', (e) => {
    setSpeed(e.target.value);
  });

  function toggleMute(){
    soundsOn = !soundsOn;
    muteBtn.textContent = soundsOn ? 'Mute' : 'Unmute';
    if(!soundsOn && audioCtx) { try{ audioCtx.close(); audioCtx = null; }catch{} }
  }

  // resize handling
  function fitCanvas() {
    // keep canvas square with device pixel ratio for crisper look
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const cssSize = Math.min(window.innerWidth - 64, 520);
    // keep original internal resolution for consistent grid
    // but scale CSS size to be responsive
    canvas.style.width = cssSize + 'px';
    canvas.style.height = cssSize + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // animation frame tick for rendering
  (function renderLoop(){
    requestAnimationFrame(renderLoop);
    draw();
  })();

  // start game
  function start(){
    loadBest();
    reset();
    setSpeed(speedRange.value);
    pauseBtn.textContent = 'Pause';
    playTone(600,0.04);
  }

  // initial load
  loadBest();
  reset();
  setSpeed(speedRange.value);

  // expose for debugging (optional)
  window.__snake = { start, reset, step, setSpeed };

})();
</script>
</body>
</html>
```

Want any tweaks? I can:

* add walls (no wrap) so hitting edge is game-over,
* increase visuals (shaders / glow),
* add levels or special food,
* export a playable `.zip` or embed High Score cloud save.

Which one next?
